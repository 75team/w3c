![](https://p1.ssl.qhimg.com/t012faed3dd3a653cba.png)

> 孤山寺北贾亭西，水面初平云脚低。几处早莺争暖树，谁家新燕啄春泥。乱花渐欲迷人眼，浅草才能没马蹄。最爱湖东行不足，绿杨阴里白沙堤。 ———— 唐.白居易《钱塘湖春行》

## 引子

春节前发的文章[《GraphQL 初探（一）》](https://mp.weixin.qq.com/s/wfXEpHkjTo5RzRgg2VOGtg)。在写文时候，笔者刚刚参加了一个聚会，于是就把题目 GraphQL 写成了 GraghQL。文章发出后，很多朋友帮我指出了问题，在此表示感谢。同时提醒各位作者：发文千万条，谨慎第一条。酒后发文章，小编两行泪。

根据之前的约定，我们将在这一篇文章中聊一个完整的前后端项目，来细细体验一下 GraphQL 的开发。在行文之中，笔者假设各位读者已经对 GraphQL 的基础概念有所了解，如果需要了解这些基础概念，可以参考[GraphQL 官方网站](https://www.graphql.org/)或参考[本系列的第一篇](https://mp.weixin.qq.com/s/wfXEpHkjTo5RzRgg2VOGtg)。这篇文字注定不会很短，那么闲话少叙，让我们开始。

## 需求

1. 建立一个图书展示系统。维护图书以及作者信息。
1. 图书信息包括标题、作者、图片等信息。
1. 图书展示：包括每页十条的图书列表、图书详情。
1. 图书信息维护：包含增加书目、删除书目、更新书目信息、上传图书封面等操作。
1. 作者维护：包含增加作者、更新作者信息等操作。
1. 当添加了新图书，界面上用 new 提供有更新提示。用户点击刷新列表。
1. 前端框架采用 Vue 完成，服务器端采用 NodeJS 的 express 框架完成。

笔者已将完整的代码示例放在：[https://github.com/liuguanyu/graphQl-demo.git](https://github.com/liuguanyu/graphQl-demo.git)，供大家参考。

## 服务端

### 领域设计

### 上手 GraphQL 服务端

我们选取 Express 作为服务端的框架，当然其它的服务端框架也可以完成类似的任务，比如 ThinkJS。何文力老师的[这篇文章](https://zhuanlan.zhihu.com/p/40348143)详细地描述了 ThinkJS 作为服务端框架时的操作方式。

#### 环境准备

请你的环境满足如下条件：

1. 之前高峰老师的文章，[ES 模块基础用法及常见使用问题](https://mp.weixin.qq.com/s/bIU_FvesizFJ3D_6KWRPHA)里面提到了使用 ES 模块的方法，我们在这个项目就来实践一下。为此，[请保证你的 NodeJS 版本大于 9.0](https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V9.md#9.0.0)。
2. 为了程序编写时候避免频繁重启，建议安装 [nodemon](https://github.com/remy/nodemon)。
   `npm install -g nodemon`

满足了上述条件，我们用`npm install`、`npm start`前端素质两连来安装依赖，并启动应用即可。

初始的代码如下:

```JavaScript
import express from 'express'
import graphqlHTTP from 'express-graphql'

const app = express();

app.use('/graphql', graphqlHTTP({
    // pass in a schema property
}));

app.listen(4000, () => {
    console.log('now listening for requests on port 4000');
});
```

此时如果访问：http://localhost:4000/graphql 会出现如图的错误：

![](https://p1.ssl.qhimg.com/t01ffd5189773ea6fab.png)

报错很清晰，我们需要提供一个 Schema 文件。

Schema 的主要用途是定义所有可供查询或者操作的字段（field），它们最终组合成一套完整的 GraphQL。与传统的 JavaScript 不同的是，Schema 本身是强类型描述的，同时，有一套自己的类型系统。[这里](http://graphql.cn/learn/schema/)介绍了这套类型系统的细节。

为此，我们修改我们的入口文件，引入 schema。

Schema 的初始代码如下

```JavaScript
import { GraphQLObjectType, GraphQLString, GraphQLSchema } from graphql

const BookType = new GraphQLObjectType({
    name: 'Book',
    fields: () => ({
        id: { type: GraphQLString },
        name: { type: GraphQLString },
        genre: { type: GraphQLString }
    })
});

const RootQuery = new GraphQLObjectType({
    name: 'RootQueryType',
    fields: {
        book: {
            type: BookType,
            args: { id: { type: GraphQLString } },
            resolve(parent, args, context){
                // code to get data from db / other source

            }
        }
    }
});

module.exports = new GraphQLSchema({
    query: RootQuery
});
```

在入口文件中引入这个 schema，同时我们引入测试期大杀器 graphiql。

```JavaScript
app.use('/graphql', graphqlHTTP({
    schema,
    graphiql: true
}));
```

因为新增了文件，需要重新启动下服务。重启后，你会发现上篇文章出现过的界面。

![](https://p2.ssl.qhimg.com/t01816dd2d089b7ae75.png)

不过有一点小瑕疵："Cannot use GraphQLSchema \"[object GraphQLSchema]\" from another module or realm."  
造成这个问题的原因是：我们的代码是用 ES Module 写的。而我们的 express-graphql 包没有提供 mjs 文件的引入方式。读者有兴趣的话，可以看一下node_modules下的对应包。

修正这一问题也不难，在 schema 里面把 GraphQL 相关的包引入方式变一下就好了。

```JavaScript
import graphql_ from 'graphql/index.js'
const { GraphQLObjectType, GraphQLString, GraphQLSchema } = graphql_
```

![](https://p5.ssl.qhimg.com/t0194549586fc30f27e.png)

问题虽然解决了，但是这对于洁癖患者来讲总有点疙瘩。这也是趟坑有时候必须付出的代价，也希望官方尽快出一致的解决方案。不过对我们来讲，所幸的是，还有搜索引擎、github issues 和 stackoverflow 以及源代码可以提供帮助。

这里简单介绍一下大杀器 GraphiQL。读者看到的界面就是它的尊容咯，这个东西很像 postman。你在左面编写查询代码，编写的过程，甚至还有拼写提示。点击“播放”按钮会直接给你返回查询结果。

同时，还可以上面的"Prettify"可以把你的代码进行格式化；"History"可以帮你记录最近的查询；"Documentation Explorer"可以根据 Schema 自动生成文档。

读者可以好好把玩一下这个神器。随着 GraphQL 的不断发展，相信这个工具也会不断的改进和提供新的惊喜。当然，[这里](https://github.com/skevy/graphiql-app/releases) 还有一个 GraphiQL 的客户端，可以下载把玩。


![](https://p0.ssl.qhimg.com/t01a583fb1553497d74.png)

#### 重点说说 Schema

让我们回到 Schema，这个也是服务端最为重要的文件之一。

一般地，一个 schema 必须至少含有一个`Query`。而`Mutation`和`Subscription`不是必须的。

首先先来完成查询（Query）部分。对于 Query，需要有一个`RootQuery`。这个`RootQuery`可以理解为外界可以访问的数据节点。而内部如何实现，数据来源究竟是数据库、网络还是数据引擎，抑或是文件、内存，是单机还是集群，对访问者来说都是透明的。外界关心的只是：这些数据是什么，字段名和类型是如何的。在 graphiql 界面右侧的“doc”上，你可以清晰度看到这一点。

所有外界能访问的 Query，都需在`RootQuery`的 fields 字段进行指定。一般地，需要对每一个字段指定类型，以及 resolver，如果不提供，GraphQL 会提供默认的 resolver。对需要的参数，可以放置在 args 中。

针对我们的例子，我们需要的查询有：根据一个 书籍 ID 查询对应书籍、列表书目、根据作者 ID 查询作者、根据封面 ID 查询图片路径等。

我们通过最简单的例子：根据一个 书籍 ID 查询对应书籍，来简单了解一下 resolver。

简单起见，我们通过将数据暂时放在 mock 里：

```JavaScript
// mock data -- start
import {
    books
} from './mocks'
// mock data -- end
```

在 resolve 中我们完成查询，并返回。

```JavaScript
resolve(parent, args, context) {
    return books.find(el => el.id == args.id);
}
```

每一个 field 的 resolve 方法，指明了获取数据的方法。此时，我们的 graphiql 界面，已经可以响应这个查询。

当然，我们的查询不一定都是同步的。对于异步的查询，resolver 本身是可以感知 Promise 的。GraphQL 查询会一直等待真正的数据返回。在实践中，我们更常见的，是从数据库中获取数据。一般地，数据库查询是异步的。resolver 这个特性，可以帮我们屏蔽一些细节。

对于数据库，我们一般需要一个统一的数据库访问对象。这可以在 resolve 的第三个参数`context`中获得。我们可以在入口文件处获取链接对象，并且通过 context 传递给 resolver。

```JavaScript
app.use('/graphql', graphqlHTTP({
    schema,
    graphiql: true,
    context: {
        database: await mysql.createConnection(db)
    }
}));
```

如果需要使用 await 关键字，我们只需将 resolver 置为`async`即可。

```JavaScript
async resolve(parent, args, context) {
    let rets = await context.database.query("select * from books where id=" + parseInt(args.id));
    return rets;
}
```

为了实现 GraphQL 声明的最大卖点，我们需要把 Author 的信息一并查出来。实际情况中，我们经常会遇到一个 book 对应多个作者情况，这时书籍和作者是多对多的关系，为了不违反关系型数据库的设计范式，可能还需要设计中间表。这里为了简化问题，我们假设每一本书只对应一个作者，书和作者是一对多的关系，则作者 ID 作为 Books 表中的一个外键。

反映在 Query 上，只需要定义出 Author 的 Type，同时，在 Book 类型中加入 Author 即可。

```JavaScript
const AuthorType = new GraphQLObjectType({
    name: 'Author',
    fields: ( ) => ({
        id: { type: GraphQLID },
        name: { type: GraphQLString },
        age: { type: GraphQLInt }
    }),
    resolve(parent, args, context){

    }
});
```

```JavaScript
// BookType
fields: ( ) => ({
    id: { type: GraphQLID },
    name: { type: GraphQLString },
    genre: { type: GraphQLString },
    author: {
        type: AuthorType,
        async resolve(parent, args, context) {
            let rets = await context.database.query("select * from author where id=" + parseInt(parent.author));
            return rets;
        }
    }
})
```

同时 Author 的查询，也可以再嵌套 Book，意义是这个作者还写了什么书。理论上，是可以任意级嵌套的。

对于列表的返回也可以在 RootQuery 上定义，此时返回的是类似于数组的方式。

查询时候：GraphQL 的最外层开始执行 resolver。无论是返回一个还是多个，如果有下一级的嵌套，对于每一个在依次执行，并把上一级的结果在 Parent 中传递过去。对于未提供 resolver 的，GraphQL 还会提供一个默认的 resolver 用于返回与 Type 上同名的数据。

如果到这里还是没有问题的话，基本的查询操作就通关了。

从原则上来讲，Types 上的 resolver 不应该承担过多的逻辑，理想状态是，仅仅是做需求的转发和参数的整理和传递。这些真正的处理，应该交给对应的业务实体，也就是引入 model 层。你最终看到的代码，可能和上述文字的描述有些许的不同。

除了查询外，GraphQL 还可以对数据改动的方法，这就是 Mutation。Mutation 的写法和 Query 类似。

```JavaScript
const Mutation = new GraphQLObjectType({
    name: 'Mutation',
    fields: {
        addAuthor: {
            type: AuthorType,
            args: {
                ...
            },
            async resolve(parent, args, context){
                ...
            }
        },
        addBook: {
            type: BookType,
            args: {
                ...
            },
            async resolve(parent, args, context){
                ...
            }
        }
    }
});
```

```JavaScript
export default new GraphQLSchema({
    query: RootQuery,
    mutation: Mutation
});
```

除了 Query 和 Mutation。有一个之前一直作为实验属性的 Subscription 操作，直到 2018 年的 6 月才正式引入。
这个操作主要是为了应对服务器端对客户端的自动推送需求。现在已有的实现，大多基于 WebSocket 完成。
这个需求中，我们把更新后的界面通知采用这个操作来实现。

Subscription的写法与Query和Mutation类似。


上面给出的，仅仅是服务器端的一种最基本写法。借助`graphql-tool`或者`ApolloServer`等包可以有更加简洁的做法。感兴趣的读者可以参阅[这里](https://blog.csdn.net/v123582/article/details/86680532)


## 参考资料

1. https://medium.com/paypal-engineering/graphql-resolvers-best-practices-cd36fdbcef55
2. https://graphql.org/learn/execution/
3. http://ju.outofmemory.cn/entry/348955
