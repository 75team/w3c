![](https://p1.ssl.qhimg.com/t012faed3dd3a653cba.png)

> 孤山寺北贾亭西，水面初平云脚低。几处早莺争暖树，谁家新燕啄春泥。乱花渐欲迷人眼，浅草才能没马蹄。最爱湖东行不足，绿杨阴里白沙堤。 ———— 唐.白居易《钱塘湖春行》

## 引子

春节前发的文章[《GraphQL 初探（一）》](https://mp.weixin.qq.com/s/wfXEpHkjTo5RzRgg2VOGtg)。在写文时候，笔者刚刚参加了一个聚会，于是就把题目 GraphQL 写成了 GraghQL。文章发出后，很多朋友帮我指出了问题，在此表示感谢。同时提醒各位作者：发文千万条，谨慎第一条。酒后发文章，小编两行泪。

根据之前的约定，我们将在这一篇文章中聊一个完整的前后端项目，来细细体验一下 GraphQL 的开发。在行文之中，笔者假设各位读者已经对 GraphQL 的基础概念有所了解，如果需要了解这些基础概念，可以参考[GraphQL 官方网站](https://www.graphql.org/)或参考[本系列的第一篇](https://mp.weixin.qq.com/s/wfXEpHkjTo5RzRgg2VOGtg)。这篇文字注定不会很短，那么闲话少叙，让我们开始。

## 需求

1. 建立一个图书展示系统。维护图书以及作者信息。
1. 图书信息包括标题、作者、图片等信息。
1. 图书展示：包括每页十条的图书列表、图书详情。
1. 图书信息维护：包含增加书目、删除书目、更新书目信息、上传图书封面等操作。
1. 作者维护：包含增加作者、更新作者信息等操作。
1. 前端框架采用 Vue 完成，服务器端采用 NodeJS 的 express 框架完成。

笔者已将完整的代码示例放在：[https://github.com/liuguanyu/graphQl-demo.git](https://github.com/liuguanyu/graphQl-demo.git)，供大家参考。

## 服务端

### 实体关系设计

尽管系统十分简单，但是从普遍的角度来讲，我们在设计数据相关的服务端代码，还是要做一些数据关系设计。很多时候，ERD 是帮我们厘清实体关系的有力武器。

从需求出发，本系统主要设计三个关系实体。

### 上手 GraphQL 服务端

我们选取 Express 作为服务端的框架，当然其它的服务端框架也可以完成类似的任务，比如 ThinkJS。何文力老师的[这篇文章](https://zhuanlan.zhihu.com/p/40348143)详细地描述了 ThinkJS 作为服务端框架时的操作方式。

#### 环境准备

请你的环境满足如下条件：

1. 之前高峰老师的文章，[ES 模块基础用法及常见使用问题](https://mp.weixin.qq.com/s/bIU_FvesizFJ3D_6KWRPHA)里面提到了使用 ES 模块的方法，我们在这个项目就来实践一下。为此，[请保证你的 NodeJS 版本大于 9.0](https://github.com/nodejs/node/blob/master/doc/changelogs/CHANGELOG_V9.md#9.0.0)。
1. 为了程序编写时候避免频繁重启，建议安装 [nodemon](https://github.com/remy/nodemon)。
   `npm install -g nodemon`

满足了上述条件，我们用`npm install`、`npm start`前端素质两连来安装依赖，并启动应用即可。

初始的代码如下:

```JavaScript
import express from 'express'
import graphqlHTTP from 'express-graphql'

const app = express();

app.use('/graphql', graphqlHTTP({
    // pass in a schema property
}));

app.listen(4000, () => {
    console.log('now listening for requests on port 4000');
});
```

此时如果访问：http://localhost:4000/graphql 会出现如图的错误：

![](https://p1.ssl.qhimg.com/t01ffd5189773ea6fab.png)

报错很清晰，我们需要提供一个 Schema 文件。

Schema 的主要用途是定义所有可供查询或者操作的字段（field），它们最终组合成一套完整的 GraphQL。与传统的 JavaScript 不同的是，Schema 本身是强类型描述的，同时，有一套自己的类型系统。[这里](http://graphql.cn/learn/schema/)介绍了这套类型系统的细节。

为此，我们修改我们的入口文件，引入 schema。

Schema 的初始代码如下

```JavaScript
import { GraphQLObjectType, GraphQLString, GraphQLSchema } from graphql

const BookType = new GraphQLObjectType({
    name: 'Book',
    fields: () => ({
        id: { type: GraphQLString },
        name: { type: GraphQLString },
        genre: { type: GraphQLString }
    })
});

const RootQuery = new GraphQLObjectType({
    name: 'RootQueryType',
    fields: {
        book: {
            type: BookType,
            args: { id: { type: GraphQLString } },
            resolve(parent, args){
                // code to get data from db / other source

            }
        }
    }
});

module.exports = new GraphQLSchema({
    query: RootQuery
});
```

一般地，一个 schema 必须至少含有一个`RootQuery`。而`Mutation`不是必须的。

在入口文件中引入这个 schema，同时我们引入测试期大杀器 graphiql。

```JavaScript
app.use('/graphql', graphqlHTTP({
    schema,
    graphiql: true
}));
```

因为新增了文件，需要重新启动下服务。重启后，你会发现上篇文章出现过的界面。

![](https://p2.ssl.qhimg.com/t01816dd2d089b7ae75.png)

不过有一点小瑕疵："Cannot use GraphQLSchema \"[object GraphQLSchema]\" from another module or realm."  
如果你的 graphQL 是版本 14 或以前的话，可能会出现这样的问题。造成这个问题的原因是：我们的代码是用 ES Module 写的。而我们的 express-graphql 包没有提供 mjs 文件的引入方式。

修正这一问题也不难，在 schema 里面把 GraphQL 相关的包引入方式变一下就好了。

```JavaScript
import graphql_ from 'graphql/index.js'
const { GraphQLObjectType, GraphQLString, GraphQLSchema } = graphql_
```

![](https://p5.ssl.qhimg.com/t0194549586fc30f27e.png)

问题虽然解决了，但是这对于洁癖患者来讲总有点疙瘩。这也是趟坑有时候必须付出的代价，也希望官方尽快出一致的解决方案。不过对我们来讲，所幸的是，还有搜索引擎和 stackoverflow 可以提供帮助。

这里简单介绍一下大杀器 graphiql。读者看到的界面就是它的尊容咯。你在左面编写查询代码，点击“播放”按钮会直接给你返回查询结果。

同时，还可以上面的"Prettify"可以把你的代码进行格式化；"History"可以帮你记录最近的查询；"Documentation Explorer"可以根据 Schema 自动生成文档。

读者可以好好把玩一下这个神器。随着 GraphQL 的不断发展，相信这个工具也会不断的改进和提供新的惊喜。

#### 重点说说 schema

让我们回到 Schema，这个也是服务端最为重点的文件。我们来看几个重点的概念：type、field、argument、resolver、graph。
