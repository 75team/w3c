> 白玉堂前一树梅，为谁零落为谁开。唯有春风最相惜，一年一度一归来。 宋.王安石《梅花》

### 引子

仿佛一瞬间，2019 年的一月份就快过去了，然而迎接元旦的时刻似乎还历历在目。时间总是这么安静的流走，以它自己的节奏，不疾不徐。猛的发现，21 世纪也过去了将近 1/5 的时间了。

每一年，都会诞生各种各样的技术。有的经过实践的检验和逐步的完善，慢慢成为业界的标准或是最佳实践；有的则慢慢淡化直至完成使命，或者演化为其他技术。

在技术的发展的上升阶段，总会有一些热点的技术，在一段时间被反复提起。它们诞生的初衷往往是一个很具象的痛点，然后在解决之后，外延不断扩大，并最终成长为一个成熟的技术或者技术栈。

今天要说的 GraghQL 可能就是这样的技术。

![](https://p4.ssl.qhimg.com/t0132bc4d40ff503e02.jpg)

### 为什么会有 GraghQL

随着前后端分离的开发模式不断的深入人心，越来越多的项目采用这种方式开发和部署。前端程序或是 App，多采用数据驱动的方式完成。数据可以采用数据接口的方式从服务端请求获得。主流的方式一般采用 REST API。

在 REST 风格的 API 中，接口数据被认为是一种“资源”，服务端提供 RESTful API，客户端通过 GET/POST/DELETE/PUT 等动作，通过 URI 对“资源”进行操作。

比如：`GET /books/1` 即是通过 GET 请求，访问 URI `/books/1`，也即服务端提供的`/books/{id}`的 RESTful API，“获取”资源，得到如下返回：

```javascript
{
    "bookId": 1,
    "title": "Black Hole Blues",
    "author": {
        "firstName": "Janna",
        "lastName": "Levin"
    },
    "page": 260,
    "press": "..."
}
```

这样的情景适应于现在的主流开发场景。不过也由一些痛点，下面列出几种：

1. 后一个请求依赖前一个请求。在依赖比较多情况下，一般会造成多次请求。对于每次请求也都需要做失败情况的处理。

举个例子，我们需要查询某本书作者的详细信息。

现有接口：`GET /books/{bookId}`返回形如下列格式：

```javascript
{
    "bookId": 1,
    "title": "Black Hole Blues",
    "authors": [
        "authorId": 100
    ],
    "page": 260,
    "press": "..."
}
```

另有一个接口，可以获得作者信息：`GET /authors/{userID}`返回形如下列格式：

```javascript
{
    "userId": 1,
    "name":{
        "firstName": "Janna",
        "lastName": "Levin"
    },
    "age": ***,
    "gender": "***",
    "photo_album":[2, 3, 5, 7, 11, 13, 17, 19, 23]
```

如果只有这两个个最简单的接口，咱们的需求还是可以完成的：首先，先通过`GET /books/1`取得作者 ID，然后再通过`GET /authors/100`就取到了作者的信息。

这里，会有两次相继的请求。后面的请求严格依赖前面的请求。这样会造成至少三个问题：

（1）在业务上，对于多个作者的情况，可能需要请求的次数更多（可以提供多 ID 查询接口变相解决）
（2）请求时间长。即便启用了`Keep-Alive`也仅仅减少了重复建立链接的时间。
（3）如果第一次请求失败，需要对错误进行处理或重试。一方面会增大复杂度，另一方面极端的网络条件下，频繁的重试，对于服务端的压力是几何级的增长。

这样的情况，有的团队可能的做法是另外提供一个面对业务的整合接口，如: `GET books/author/1`，可以间接地解决问题。

这样做的问题在于，一个前端界面上的问题，直接透给了服务端。业务的变化，会造成这种接口的爆炸增长抑或成批的废弃，给维护造成负担。

2. 依然是上面的例子。现在对于多端的开发，需要的数据不同。如：手机上仅需获取作者，而 PC 上需要通过`photo_album`字段所示的相册图集取得第一个相册的第一张照片......。为了达到这样的效果，一般的团队可能会为每种端开发一种特定 API，或者是统一把最冗余的数据接口提供出去。这样显然都不是最理想的。

![](https://p5.ssl.qhimg.com/t01ee3594ca7e227b9d.png)
![](https://p0.ssl.qhimg.com/t0177b8d2619a52079d.png)
![](https://p3.ssl.qhimg.com/t017f812851029c2a7d.jpg)

这些痛点至少代表大家在开发中经常遇到的情况。GraphQL 也许可以成为解决这些问题的一个不错的选择。

### 什么是 GraphQL

那么，什么是 GraphQL 呢？

![](https://p5.ssl.qhimg.com/t015a9c02d29231d8f4.png)

GraphQL 是一套关于数据查询和操作的语法标准，它极为适合用于 API 交互。它由 Facebook 在 2012 年开发并在内部使用。2015 年对外发布。2018 年 11 月 7 日，GraphQL 由 Facebook 转交由新成立的 GraphQL 基金会管理。

简单的说来，GraphQL 提供了一种机制，允许客户端定义返回的数据结构。当数据返回时候，精确的根据定义返回所需的数据结构。这种机制避免了大量冗余数据的返回，也使得合并多次请求成为可能。

[这里](https://www.graphql.org/)是 GraphQL 官方网站。国内还有一份中文的[镜像网站](https://graphql.cn/)。

GraphQL 确切讲是一种语言标准，是与实现语言无关的。实际上，Facebook 和开源届，已经有了针对 GraphQL 的[各种语言的实现](https://www.graphql.org/code/#go)。

#### 感受 GraphQL

为了对 GraphQL 有一个感性的认识，我们来做一个简单的例子来体验一下 GraphQL 的全流程。

#### 类型系统

https://www.youtube.com/watch?v=IvsANO0qZEg 视频讲解
